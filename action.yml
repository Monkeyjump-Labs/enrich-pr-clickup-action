name: Enrich PR with ClickUp Information
description: 'Extracts ClickUp ticket IDs from a PR, fetches labels from ClickUp, and applies them to the PR.'

inputs:
  clickup_api_token:
    description: The clickup API token that has access to retrieve ticket information
    required: true
  clickup_team_id:
    description: 'The ClickUp team/workspace ID (required for custom task IDs like ENG-123). Find it in your ClickUp URL.'
    required: false
  github_token:
    description: 'GITHUB_TOKEN or a repo scoped PAT'
    default: ${{ github.token }}
    required: false
  pr_number:
    description: 'The number of the pull request to apply labels to'
    required: true
  fail_on_no_ticket:
    description: 'Whether to fail the action if no ClickUp ticket is found in the PR'
    default: 'true'
    required: false

runs:
  using: 'composite'
  steps:
    - name: Fetch PR metadata
      id: fetch_pr
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        PR_NUMBER: ${{ inputs.pr_number }}
      run: |
        echo "üîé Fetching metadata for PR #$PR_NUMBER..."
        PR_JSON=$(gh pr view "$PR_NUMBER" --json title,body --repo "$GITHUB_REPOSITORY")
        PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')
        PR_BODY=$(echo "$PR_JSON" | jq -r '.body')
        echo "PR_TITLE<<EOF" >> $GITHUB_OUTPUT
        echo "$PR_TITLE" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "PR_BODY<<EOF" >> $GITHUB_OUTPUT
        echo "$PR_BODY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Extract ClickUp Ticket IDs from PR
      id: extract_tickets
      shell: bash
      env:
        PR_TITLE: ${{ steps.fetch_pr.outputs.PR_TITLE }}
        PR_BODY: ${{ steps.fetch_pr.outputs.PR_BODY }}
      run: |
        echo "üîé Extracting ClickUp ticket IDs from PR..."
        # Match both standard ClickUp IDs (6+ alphanumeric) and custom IDs (PREFIX-NUMBER like #MY-1, #HERO-4)
        TICKET_IDS=$(echo "$PR_TITLE $PR_BODY" | grep -oE '#([a-zA-Z0-9]{6,}|[A-Za-z]+-[0-9]+)' | tr '\n\r' ',' | sed -E "s/,$//g" || true)
        if [ -z "$TICKET_IDS" ]; then
          echo "‚ùå No ticket numbers found"
        else
          echo "üöÄ Found tickets: $TICKET_IDS"
          # Print each ticket with its URL
          for T in $(echo "$TICKET_IDS" | tr ',' ' '); do
            T_NO_HASH="${T/#\#/}"
            echo "   ‚Üí Ticket $T (https://app.clickup.com/t/${T_NO_HASH})"
          done
          echo "TICKET_IDS=$TICKET_IDS" >> "$GITHUB_OUTPUT"
        fi

    - name: Fail if no ticket found
      if: ${{ steps.extract_tickets.outputs.TICKET_IDS == '' && inputs.fail_on_no_ticket == 'true' }}
      shell: bash
      run: |
        echo "‚ùå No ClickUp Ticket Linked"
        exit 1

    - name: Fetch and Aggregate ClickUp Labels
      id: fetch_labels
      if: ${{ steps.extract_tickets.outputs.TICKET_IDS != '' }}
      shell: bash
      env:
        TICKET_IDS: ${{ steps.extract_tickets.outputs.TICKET_IDS }}
        CLICKUP_API_TOKEN: ${{ inputs.clickup_api_token }}
        CLICKUP_TEAM_ID: ${{ inputs.clickup_team_id }}
      run: |
        echo "üîé Fetching and aggregating ClickUp labels..."
        echo "üöÄ Unique ticket IDs: $TICKET_IDS"
        LABELS=""

        # Function to check if a ticket ID is a custom ID (PREFIX-NUMBER format)
        is_custom_id() {
          [[ "$1" =~ ^[A-Za-z]+-[0-9]+$ ]]
        }

        # Function to resolve a custom ID to an internal ClickUp task ID
        resolve_custom_id() {
          local CUSTOM_ID="$1"
          if [ -z "$CLICKUP_TEAM_ID" ]; then
            echo "‚ö†Ô∏è Custom ID '$CUSTOM_ID' detected but no clickup_team_id provided. Cannot resolve." >&2
            return 1
          fi
          echo "üîç Searching for custom ID '$CUSTOM_ID' in team $CLICKUP_TEAM_ID..." >&2
          local SEARCH_RESPONSE=$(curl -s -k \
            -H "Authorization: $CLICKUP_API_TOKEN" \
            -H "Content-Type: application/json" \
            "https://api.clickup.com/api/v2/task/${CUSTOM_ID}?custom_task_ids=true&team_id=${CLICKUP_TEAM_ID}&include_closed=true&include_subtasks=true")

          # Search for the task with matching custom_id in the response
          local INTERNAL_ID=$(echo "$SEARCH_RESPONSE" | jq -r .id)
          if [ -z "$INTERNAL_ID" ] || [ "$INTERNAL_ID" = "null" ]; then
            echo "‚ö†Ô∏è Could not find task with custom ID '$CUSTOM_ID'" >&2
            return 1
          fi

          echo "‚úÖ Resolved custom ID '$CUSTOM_ID' to internal ID '$INTERNAL_ID'" >&2
          echo "$INTERNAL_ID"
        }

        # Function to fetch task and extract labels
        # Outputs tag names (one per line) and a __TYPE_ID__:<id> line for task type detection
        fetch_task_labels() {
          local TASK_ID="$1"
          local RESPONSE=$(curl -s -k -H "Authorization: $CLICKUP_API_TOKEN" \
            "https://api.clickup.com/api/v2/task/${TASK_ID}")

          local TASK_LABELS=$(echo "$RESPONSE" | jq -r '.tags[].name' 2>/dev/null)
          if [ "$TASK_LABELS" ]; then
            echo "$TASK_LABELS"
          fi

          # Output custom_type_id for caller to resolve (associative arrays don't survive subshells)
          local TYPE_ID=$(echo "$RESPONSE" | jq -r '.custom_item_id // empty' 2>/dev/null)
          if [ -n "$TYPE_ID" ]; then
            echo "__TYPE_ID__:$TYPE_ID"
          fi

          # Check for parent task
          local PARENT_ID=$(echo "$RESPONSE" | jq -r '.parent' 2>/dev/null | grep -oE '[a-zA-Z0-9]{6,}' || true)
          if [ "$PARENT_ID" ]; then
            echo "üöÄ Getting labels for parent ticket #${PARENT_ID} (https://app.clickup.com/t/${PARENT_ID})" >&2
            local PARENT_RESPONSE=$(curl -s -k -H "Authorization: $CLICKUP_API_TOKEN" \
              "https://api.clickup.com/api/v2/task/${PARENT_ID}")
            local PARENT_LABELS=$(echo "$PARENT_RESPONSE" | jq -r '.tags[].name' 2>/dev/null)
            if [ "$PARENT_LABELS" ]; then
              echo "$PARENT_LABELS"
            fi
          fi
        }

        # Build a lookup map of custom task type IDs to names
        declare -A CUSTOM_TYPE_MAP
        if [ -n "$CLICKUP_TEAM_ID" ]; then
          echo "üîç Fetching custom task types for team $CLICKUP_TEAM_ID..."
          CUSTOM_ITEMS_RESPONSE=$(curl -s -k \
            -H "Authorization: $CLICKUP_API_TOKEN" \
            "https://api.clickup.com/api/v2/team/${CLICKUP_TEAM_ID}/custom_item")
          CUSTOM_ITEMS=$(echo "$CUSTOM_ITEMS_RESPONSE" | jq -r '.custom_items[]? | "\(.id)=\(.name)"' 2>/dev/null)
          while IFS='=' read -r TYPE_ID TYPE_NAME; do
            if [ -n "$TYPE_ID" ]; then
              CUSTOM_TYPE_MAP["$TYPE_ID"]="$TYPE_NAME"
              echo "   ‚Üí Registered type: $TYPE_NAME (id: $TYPE_ID)"
            fi
          done <<< "$CUSTOM_ITEMS"
          echo "‚úÖ Loaded ${#CUSTOM_TYPE_MAP[@]} custom task types"
        else
          echo "‚ö†Ô∏è No clickup_team_id provided - task type detection disabled"
        fi

        if [ "$TICKET_IDS" ]; then
          IFS=',' read -r -a TICKET_ARRAY <<< "$TICKET_IDS"
          for TICKET_ID_RAW in "${TICKET_ARRAY[@]}"; do
            # Remove the '#' from the raw ID for API calls
            TICKET_ID="${TICKET_ID_RAW/#\#/}"

            # Determine if this is a custom ID or standard ID
            if is_custom_id "$TICKET_ID"; then
              echo "üöÄ Custom ID detected: $TICKET_ID"
              INTERNAL_ID=$(resolve_custom_id "$TICKET_ID")
              if [ $? -ne 0 ] || [ -z "$INTERNAL_ID" ]; then
                echo "‚ö†Ô∏è Skipping ticket $TICKET_ID - could not resolve custom ID"
                continue
              fi
              TICKET_ID="$INTERNAL_ID"
            fi

            echo "üöÄ Getting labels for ticket #${TICKET_ID} (https://app.clickup.com/t/${TICKET_ID})"
            TASK_OUTPUT=$(fetch_task_labels "$TICKET_ID")

            # Extract custom type ID and resolve to a label using the map (in this shell, not a subshell)
            TYPE_LINE=$(echo "$TASK_OUTPUT" | grep '^__TYPE_ID__:' || true)
            TASK_LABELS=$(echo "$TASK_OUTPUT" | grep -v '^__TYPE_ID__:' || true)
            if [ -n "$TYPE_LINE" ]; then
              TYPE_ID="${TYPE_LINE#__TYPE_ID__:}"
              if [ "${CUSTOM_TYPE_MAP[$TYPE_ID]+_}" ]; then
                TYPE_NAME="${CUSTOM_TYPE_MAP[$TYPE_ID]}"
                TYPE_NAME_LOWER=$(echo "$TYPE_NAME" | tr '[:upper:]' '[:lower:]')
                if [ "$TYPE_NAME_LOWER" != "task" ] && [ "$TYPE_NAME_LOWER" != "item" ]; then
                  echo "‚úÖ Detected task type: '$TYPE_NAME'"
                  TASK_LABELS=$(printf '%s\n%s' "$TASK_LABELS" "$TYPE_NAME_LOWER")
                fi
              fi
            fi

            if [ "$TASK_LABELS" ]; then
              LABELS="$LABELS\n$TASK_LABELS"
            fi
          done
          UNIQUE_LABELS=$(echo -e "$LABELS" | sort | uniq | grep -v "^\s*$" | tr '\n' ',' | sed 's/,$//' || true)
          echo "üöÄ Final aggregated labels: $UNIQUE_LABELS"
          echo "LABELS=$UNIQUE_LABELS" >> "$GITHUB_OUTPUT"
        else
          echo "‚ö†Ô∏è No ticket numbers found - skipping"
        fi

    - name: Fail if no labels found
      if: ${{ steps.fetch_labels.outputs.LABELS == '' && inputs.fail_on_no_ticket == 'true' }}
      shell: bash
      run: |
        echo "‚ùå No ClickUp Labels Found"
        exit 1

    - name: Apply Labels to PR
      if: ${{ steps.fetch_labels.outputs.LABELS != '' }}
      shell: bash
      env:
        LABELS: ${{ steps.fetch_labels.outputs.LABELS }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO: ${{ github.repository }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        echo "üè∑Ô∏è Applying labels to PR #$PR_NUMBER..."
        if [ "$LABELS" ]; then
          IFS=',' read -r -a LABEL_ARRAY <<< "${LABELS}"
          for LABEL in "${LABEL_ARRAY[@]}"; do
            echo "   ‚Üí Applying label '$LABEL'"
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/issues/$PR_NUMBER/labels" \
              -d "{\"labels\":[\"${LABEL}\"]}"
          done
        else
          echo "‚ö†Ô∏è No labels found - skipping"
        fi
